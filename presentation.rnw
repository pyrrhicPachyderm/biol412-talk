<<child="theme.rnw">>=
@

%NB: Need to use [fragile] on frames with R chunks, or line breaks in printed code vanish.
%Also on frames with # in \url.

\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{multirow}
\usepackage{bigdelim}

<<include=FALSE>>=
	library(deSolve)
@

<<include=FALSE>>=
	bmatrix <- function(mat) {
		#From https://stackoverflow.com/a/54088015
		begin <- "\\begin{bmatrix}"
		end <- "\\end{bmatrix}"
		line_strings <- apply(mat, 1, function(row) {
			paste(
				paste(row, collapse = "&"),
					"\\\\"
				)
			})
		paste(c(begin, line_strings, end), collapse="")
	}
@

<<include=FALSE>>=
	block_matrix <- function(row_groups, col_groups) {
		#Produces the LaTeX text for a blocked interaction matrix.
		#The groups are given as a vector of the number of species in each group.
		
		delim_width <- "2mm"
		
		num_species_rows <- sum(row_groups)
		num_species_cols <- sum(col_groups)
		
		num_rows <- num_species_rows + 1 #One for the labels.
		num_cols <- num_species_cols + 3 #One for the labels, one for each delimiter.
		
		begin <- paste(c("\\begin{array}{", rep("c", num_cols), "}"), collapse="")
		end <- "\\end{array}"
		
		label_line <- paste(c("","",1:num_species_cols,""), collapse="&")
		
		get_row_group_filler <- function(row_species_num) {
			paste(c(row_species_num,rep("",num_cols-1)),collapse="&")
		}
		
		get_row_group_line <- function(row_species_num, row_group_index) {
			ldelim <- ifelse(row_species_num == 1,
				paste0("\\ldelim[{",num_species_rows,"}{",delim_width,"}"),
				""
			)
			rdelim <- ifelse(row_species_num == 1,
				paste0("\\rdelim]{",num_species_rows,"}{",delim_width,"}"),
				""
			)
			return(paste(c(
				row_species_num,
				ldelim,
				unlist(sapply(1:length(col_groups),
					function(col_group_index) {
						paste0("\\multicolumn{",col_groups[col_group_index],"}{c}{\\multirow{",row_groups[row_group_index],"}*{$\\alpha_{",row_group_index,col_group_index,"}$}}")
					}
				)),
				rdelim
			), collapse="&"))
		}
		
		get_row_group_lines <- function(row_species_num, row_group_index) {
			first_line <- get_row_group_line(row_species_num, row_group_index)
			row_group_size <- row_groups[row_group_index]
			if(row_group_size == 1) {
				return(first_line)
			} else {
				return(c(
					first_line,
					sapply((row_species_num+1):(row_species_num+row_group_size-1), get_row_group_filler)
				))
			}
		}
		
		species_lines <- unlist(sapply(1:length(row_groups),
			function(row_group_index) {
				get_row_group_lines(sum(row_groups[0:(row_group_index-1)])+1, row_group_index)
			}
		))
		
		content_lines <- paste(c(label_line,species_lines), c("\\\\"), sep="", collapse="\n")
		
		paste(c(begin, content_lines, end), collapse="\n")
	}
@

<<include=FALSE>>=
	par_adjust <- function(variable, index, value) {
		#The nature of par makes it hard to set just one value in a vector.
		#This sets the indexth value in variable to value.
		v <- par(variable)
		v[index] <- value
		l <- list(v)
		names(l) <- variable
		par(l)
	}
@

\title{Block Regularising Lotka--Volterra}
\author{
	Christopher Brown
}
\date{}

\begin{document}

\begin{frame}[fragile]{The Lotka--Volterra Model}
	<<echo=FALSE>>=
		#Using the chaotic system from
		#https://en.wikipedia.org/wiki/Competitive_Lotka%E2%80%93Volterra_equations#4-dimensional_example
		
		num_species <- 4
		
		#These is the equilibrium, plus a perturbation.
		initial_population <- c(
			0.3013, 0.4586, 0.1307, 0.3557
		) + 0.1
		
		growth_rates <- matrix(c(
			1, 0.72, 1.53, 1.27
		), nrow=num_species, ncol=1, byrow=T)
		
		competition_coefficients <- matrix(c(
			1, 1.09, 1.52, 0,
			0, 1, 0.44, 1.36,
			2.33, 0, 1, 0.47,
			1.21, 0.51, 0.35, 1
		), nrow=num_species, ncol=num_species, byrow=T)
		
		params <- list(
			growth_rates = growth_rates,
			competition_coefficients = competition_coefficients
		)
		
		derivative <- function(t, y, params) {
			y <- matrix(y, ncol=1)
			d <- y * params$growth_rates *
				(1 - params$competition_coefficients %*% y)
			return(list(as.vector(d)))
		}
		
		max_time <- 200
		time_step <- 0.1
		times <- seq(0, max_time, by=time_step)
		
		results <- ode(initial_population, times, derivative, params)
	@
	
	\vspace{-1cm}
	
	\onslide<+->{
		<<echo=FALSE, fig.height=4>>=
			#Adjust distance of axis labels.
			par_adjust("mgp", 1, 2.2)
			plot(NULL,
				xlim=c(min(results[,'time']),max(results[,'time'])),
				ylim=c(0,max(results[, 2:ncol(results)])*1.1),
				bty='n',
				xaxs='i',
				yaxs='i',
				xlab="Time",
				ylab="Population density")
			
			for (i in 2:ncol(results)) {
				lines(results[,'time'], results[,i], lwd=2, col=i)
			}
		@
	}
	
	\vspace{-0.9cm}
	
	\onslide<+->{
		\begin{align*}
			r &= \Sexpr{bmatrix(growth_rates)} &
			\alpha &= \Sexpr{bmatrix(competition_coefficients)} \\
		\end{align*}
	}
\end{frame}
\note{
	
}

\end{document}
