<<child="theme.rnw">>=
@

%NB: Need to use [fragile] on frames with R chunks, or line breaks in printed code vanish.
%Also on frames with # in \url.

\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{array}
\usepackage{multirow}
\usepackage{bigdelim}
\usepackage{arydshln}

<<include=FALSE>>=
	library(deSolve)
@

<<include=FALSE>>=
	bmatrix <- function(mat) {
		#From https://stackoverflow.com/a/54088015
		begin <- "\\begin{bmatrix}"
		end <- "\\end{bmatrix}"
		line_strings <- apply(mat, 1, function(row) {
			paste(
				paste(row, collapse = "&"),
					"\\\\"
				)
			})
		paste(c(begin, line_strings, end), collapse="")
	}
@

\arrayrulecolor{black!35}

\newlength{\colwidth}
\settowidth{\colwidth}{$\alpha_{99}$}
<<include=FALSE>>=
	#First, define a pair of helper functions, that take a list of block sizes and an index, and return helpful info.
	block_index <- function(index, block_sizes) {
		block_indices <- rep(1:length(block_sizes), block_sizes)
		return(block_indices[index])
	}
	
	is_begin_block <- function(index, block_sizes) {
		if(index == 1) return(TRUE)
		block_indices <- rep(1:length(block_sizes), block_sizes)
		return(block_indices[index] != block_indices[index-1])
	}
	
	block_matrix <- function(row_groups, col_groups, full_interior=FALSE, lines=FALSE, label_lines=lines) {
		#Produces the LaTeX text for a blocked interaction matrix.
		#The groups are given as a vector of the number of species in each group.
		
		delim_width <- "2mm"
		use_dashed_lines <- TRUE
		dashed_line_spec <- "1pt/1pt" #Dash/gap.
		
		num_species_rows <- sum(row_groups)
		num_species_cols <- sum(col_groups)
		
		label_row_groups <- row_groups
		label_col_groups <- col_groups
		
		if(full_interior) {
			row_groups <- rep(1, num_species_rows)
			col_groups <- rep(1, num_species_cols)
		}
		
		alignment <- function(num_cols, has_rule) {
			paste0(">{\\centering\\arraybackslash}p{\\dimexpr",num_cols,"\\colwidth+",2*(num_cols-1),"\\arraycolsep+",num_cols-has_rule,"\\arrayrulewidth\\relax}")
		}
		
		divider_command <- ifelse(use_dashed_lines, paste0(";{",dashed_line_spec,"}"), "|")
		cline_command <- ifelse(use_dashed_lines,
			function(col1,col2){paste0("\\cdashline{",col1,"-",col2,"}[",dashed_line_spec,"]")},
			function(col1,col2){paste0("\\cline{",col1,"-",col2,"}")}
		)
		
		begin <- paste(c("\\begin{array}{cc", rep(alignment(1,FALSE), num_species_cols), "c}"), collapse="")
		end <- "\\end{array}"
		
		get_species_column_label <- function(col_species_num) {
			has_divider <- col_species_num > 1 & is_begin_block(col_species_num, label_col_groups) & label_lines
			divider <- ifelse(has_divider, divider_command, "")
			hspace <- ifelse(has_divider, "", "\\hspace{\\arrayrulewidth}") #To compensate for a shift in alignment if it has no divider.
			return(paste0("\\multicolumn{1}{",divider,alignment(1,has_divider),"}{",hspace,col_species_num,"}"))
		}
		
		species_column_labels <- sapply(1:num_species_cols, get_species_column_label)
		
		label_line <- paste(c("","",species_column_labels,""), collapse="&")
		
		get_row_line <- function(row_species_num) {
			row_group_index <- block_index(row_species_num, row_groups)
			ldelim <- ifelse(row_species_num == 1,
				paste0("\\ldelim[{",num_species_rows,"}{",delim_width,"}"),
				""
			)
			rdelim <- ifelse(row_species_num == 1,
				paste0("\\rdelim]{",num_species_rows,"}{",delim_width,"}"),
				""
			)
			cline <- ifelse(row_species_num > 1 & is_begin_block(row_species_num, row_groups) & lines,
				cline_command(3,num_species_cols+2),
				""
			)
			index_cline <- ifelse(row_species_num > 1 & is_begin_block(row_species_num, label_row_groups) & label_lines,
				cline_command(1,1),
				""
			)
			row_line <- paste(c(
				row_species_num,
				ldelim,
				unlist(sapply(1:length(col_groups),
					function(col_group_index) {
						multirow <- ifelse(is_begin_block(row_species_num, row_groups),
							paste0("\\multirow{",row_groups[row_group_index],"}*{$\\alpha_{",row_group_index,col_group_index,"}$}"),
							""
						)
						has_divider <- col_group_index != 1 & lines
						divider <- ifelse(has_divider, divider_command, "")
						paste0("\\multicolumn{",col_groups[col_group_index],"}{",divider,alignment(col_groups[col_group_index],has_divider),"}{",multirow,"}")
					}
				)),
				rdelim
			), collapse="&")
			return(paste0(index_cline,cline,row_line))
		}
		
		species_lines <- sapply(1:num_species_rows, get_row_line)
		
		content_lines <- paste(c(label_line,species_lines), c("\\\\"), sep="", collapse="\n")
		
		paste(c(begin, content_lines, end), collapse="\n")
	}
@

<<include=FALSE>>=
	par_adjust <- function(variable, index, value) {
		#The nature of par makes it hard to set just one value in a vector.
		#This sets the indexth value in variable to value.
		v <- par(variable)
		v[index] <- value
		l <- list(v)
		names(l) <- variable
		par(l)
	}
@

\title{Block Regularising Lotka--Volterra}
\author{
	Christopher Brown
}
\date{}

\begin{document}

\begin{frame}[fragile]{The Lotka--Volterra Model}
	<<echo=FALSE>>=
		#Using the chaotic system from
		#https://en.wikipedia.org/wiki/Competitive_Lotka%E2%80%93Volterra_equations#4-dimensional_example
		
		num_species <- 4
		
		#These is the equilibrium, plus a perturbation.
		initial_population <- c(
			0.3013, 0.4586, 0.1307, 0.3557
		) + 0.1
		
		growth_rates <- matrix(c(
			1, 0.72, 1.53, 1.27
		), nrow=num_species, ncol=1, byrow=T)
		
		competition_coefficients <- matrix(c(
			1, 1.09, 1.52, 0,
			0, 1, 0.44, 1.36,
			2.33, 0, 1, 0.47,
			1.21, 0.51, 0.35, 1
		), nrow=num_species, ncol=num_species, byrow=T)
		
		params <- list(
			growth_rates = growth_rates,
			competition_coefficients = competition_coefficients
		)
		
		derivative <- function(t, y, params) {
			y <- matrix(y, ncol=1)
			d <- y * params$growth_rates *
				(1 - params$competition_coefficients %*% y)
			return(list(as.vector(d)))
		}
		
		max_time <- 200
		time_step <- 0.1
		times <- seq(0, max_time, by=time_step)
		
		results <- ode(initial_population, times, derivative, params)
	@
	
	\vspace{-1cm}
	
	\onslide<+->{
		<<echo=FALSE, fig.height=4>>=
			#Adjust distance of axis labels.
			par_adjust("mgp", 1, 2.2)
			plot(NULL,
				xlim=c(min(results[,'time']),max(results[,'time'])),
				ylim=c(0,max(results[, 2:ncol(results)])*1.1),
				bty='n',
				xaxs='i',
				yaxs='i',
				xlab="Time",
				ylab="Population density")
			
			for (i in 2:ncol(results)) {
				lines(results[,'time'], results[,i], lwd=2, col=i)
			}
		@
	}
	
	\vspace{-0.9cm}
	
	\onslide<+->{
		\begin{align*}
			r &= \Sexpr{bmatrix(growth_rates)} &
			\alpha &= \Sexpr{bmatrix(competition_coefficients)} \\
		\end{align*}
	}
\end{frame}
\note{
	
}

\begin{frame}{Too Many Parameters}
	\only<+>{
		\begin{align*}
			\Sexpr{block_matrix(rep(1,8),rep(1,8),full_interior=T,label_lines=T)}
		\end{align*}
	}
	
	\only<+>{
		\begin{align*}
			\Sexpr{block_matrix(rep(1,8),c(2,1,1,1,1,1,1),full_interior=T,label_lines=T)}
		\end{align*}
	}
	
	\only<+>{
		\begin{align*}
			\Sexpr{block_matrix(rep(1,8),c(2,1,1,1,1,1,1),label_lines=T)}
		\end{align*}
	}
	
	\only<+>{
		\begin{align*}
			\Sexpr{block_matrix(c(2,1,1,1,1,1,1),c(2,1,1,1,1,1,1),label_lines=T)}
		\end{align*}
	}
	
	\only<+>{
		\begin{align*}
			\Sexpr{block_matrix(c(2,3,2,1),c(2,2,2,2),lines=T)}
		\end{align*}
	}
\end{frame}
\note[itemize]{
	\item A row is a species' competitive response.
	\item A column is a species' competitive effect.
	\item Too many parameters; need at least one experiment per parameter.
	\item Suppose two species have a similar competitive effect.
	\item We can give them the same set of parameters.
	\item Suppose they have the same response to competition as well.
	\item We can combine their parameters in that way too.
	\item We can go through the whole thing, blocking species up appropriately.
	\item One quarter the number of experiments.
	\item Note that the last species is still considered special in its response to competition; this is valid.
}

\begin{frame}{Questions \& Aims}
	\begin{enumerate}
		\item<+-> How do species group?
		\begin{itemize}
			\item Phylogeny?
			\item Traits?
		\end{itemize}
		\item<+-> Find best grouping algorithm
		\item<+-> Find groups using incomplete data
		\begin{itemize}
			\item Do fewer experiments.
		\end{itemize}
	\end{enumerate}
\end{frame}

\end{document}
