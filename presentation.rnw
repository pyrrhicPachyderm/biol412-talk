<<child="theme.rnw">>=
@

%NB: Need to use [fragile] on frames with R chunks, or line breaks in printed code vanish.
%Also on frames with # in \url.

\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{multirow}
\usepackage{bigdelim}

<<include=FALSE>>=
	library(deSolve)
@

<<include=FALSE>>=
	bmatrix <- function(mat) {
		#From https://stackoverflow.com/a/54088015
		begin <- "\\begin{bmatrix}"
		end <- "\\end{bmatrix}"
		line_strings <- apply(mat, 1, function(row) {
			paste(
				paste(row, collapse = "&"),
					"\\\\"
				)
			})
		paste(c(begin, line_strings, end), collapse="")
	}
@

<<include=FALSE>>=
	#First, define a pair of helper functions, that take a list of block sizes and an index, and return helpful info.
	block_index <- function(index, block_sizes) {
		block_indices <- rep(1:length(block_sizes), block_sizes)
		return(block_indices[index])
	}
	
	is_begin_block <- function(index, block_sizes) {
		if(index == 1) return(TRUE)
		block_indices <- rep(1:length(block_sizes), block_sizes)
		return(block_indices[index] != block_indices[index-1])
	}
	
	block_matrix <- function(row_groups, col_groups, full_interior=FALSE, lines=FALSE, label_lines=lines) {
		#Produces the LaTeX text for a blocked interaction matrix.
		#The groups are given as a vector of the number of species in each group.
		
		delim_width <- "2mm"
		
		num_species_rows <- sum(row_groups)
		num_species_cols <- sum(col_groups)
		
		num_rows <- num_species_rows + 1 #One for the labels.
		num_cols <- num_species_cols + 3 #One for the labels, one for each delimiter.
		
		label_row_groups <- row_groups
		label_col_groups <- col_groups
		
		if(full_interior) {
			row_groups <- rep(1, num_species_rows)
			col_groups <- rep(1, num_species_cols)
		}
		
		begin <- paste(c("\\begin{array}{", rep("c", num_cols), "}"), collapse="")
		end <- "\\end{array}"
		
		get_species_column_label <- function(col_species_num) {
			alignment <- ifelse(col_species_num > 1 & is_begin_block(col_species_num, label_col_groups) & label_lines,
				"|c",
				"c"
			)
			return(paste0("\\multicolumn{1}{",alignment,"}{",col_species_num,"}"))
		}
		
		species_column_labels <- sapply(1:num_species_cols, get_species_column_label)
		
		label_line <- paste(c("","",species_column_labels,""), collapse="&")
		
		get_row_line <- function(row_species_num) {
			row_group_index <- block_index(row_species_num, row_groups)
			ldelim <- ifelse(row_species_num == 1,
				paste0("\\ldelim[{",num_species_rows,"}{",delim_width,"}"),
				""
			)
			rdelim <- ifelse(row_species_num == 1,
				paste0("\\rdelim]{",num_species_rows,"}{",delim_width,"}"),
				""
			)
			cline <- ifelse(row_species_num > 1 & is_begin_block(row_species_num, row_groups) & lines,
				paste0("\\cline{3-",num_species_cols+2,"}"),
				""
			)
			index_cline <- ifelse(row_species_num > 1 & is_begin_block(row_species_num, label_row_groups) & label_lines,
				paste0("\\cline{1-1}"),
				""
			)
			row_line <- paste(c(
				row_species_num,
				ldelim,
				unlist(sapply(1:length(col_groups),
					function(col_group_index) {
						multirow <- ifelse(is_begin_block(row_species_num, row_groups),
							paste0("\\multirow{",row_groups[row_group_index],"}*{$\\alpha_{",row_group_index,col_group_index,"}$}"),
							""
						)
						alignment <- ifelse(col_group_index != 1 & lines,
							"|c",
							"c"
						)
						paste0("\\multicolumn{",col_groups[col_group_index],"}{",alignment,"}{",multirow,"}")
					}
				)),
				rdelim
			), collapse="&")
			return(paste0(index_cline,cline,row_line))
		}
		
		species_lines <- sapply(1:num_species_rows, get_row_line)
		
		content_lines <- paste(c(label_line,species_lines), c("\\\\"), sep="", collapse="\n")
		
		paste(c(begin, content_lines, end), collapse="\n")
	}
@

<<include=FALSE>>=
	par_adjust <- function(variable, index, value) {
		#The nature of par makes it hard to set just one value in a vector.
		#This sets the indexth value in variable to value.
		v <- par(variable)
		v[index] <- value
		l <- list(v)
		names(l) <- variable
		par(l)
	}
@

\title{Block Regularising Lotka--Volterra}
\author{
	Christopher Brown
}
\date{}

\begin{document}

\begin{frame}[fragile]{The Lotka--Volterra Model}
	<<echo=FALSE>>=
		#Using the chaotic system from
		#https://en.wikipedia.org/wiki/Competitive_Lotka%E2%80%93Volterra_equations#4-dimensional_example
		
		num_species <- 4
		
		#These is the equilibrium, plus a perturbation.
		initial_population <- c(
			0.3013, 0.4586, 0.1307, 0.3557
		) + 0.1
		
		growth_rates <- matrix(c(
			1, 0.72, 1.53, 1.27
		), nrow=num_species, ncol=1, byrow=T)
		
		competition_coefficients <- matrix(c(
			1, 1.09, 1.52, 0,
			0, 1, 0.44, 1.36,
			2.33, 0, 1, 0.47,
			1.21, 0.51, 0.35, 1
		), nrow=num_species, ncol=num_species, byrow=T)
		
		params <- list(
			growth_rates = growth_rates,
			competition_coefficients = competition_coefficients
		)
		
		derivative <- function(t, y, params) {
			y <- matrix(y, ncol=1)
			d <- y * params$growth_rates *
				(1 - params$competition_coefficients %*% y)
			return(list(as.vector(d)))
		}
		
		max_time <- 200
		time_step <- 0.1
		times <- seq(0, max_time, by=time_step)
		
		results <- ode(initial_population, times, derivative, params)
	@
	
	\vspace{-1cm}
	
	\onslide<+->{
		<<echo=FALSE, fig.height=4>>=
			#Adjust distance of axis labels.
			par_adjust("mgp", 1, 2.2)
			plot(NULL,
				xlim=c(min(results[,'time']),max(results[,'time'])),
				ylim=c(0,max(results[, 2:ncol(results)])*1.1),
				bty='n',
				xaxs='i',
				yaxs='i',
				xlab="Time",
				ylab="Population density")
			
			for (i in 2:ncol(results)) {
				lines(results[,'time'], results[,i], lwd=2, col=i)
			}
		@
	}
	
	\vspace{-0.9cm}
	
	\onslide<+->{
		\begin{align*}
			r &= \Sexpr{bmatrix(growth_rates)} &
			\alpha &= \Sexpr{bmatrix(competition_coefficients)} \\
		\end{align*}
	}
\end{frame}
\note{
	
}

\end{document}
